// AsyncAPI Streaming Client for {{entityName}}
package asyncapi

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/url"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// StreamingConfig holds client configuration
type StreamingConfig struct {
	URL               string        `json:"url"`
	APIKey            string        `json:"apiKey,omitempty"`
	ReconnectInterval time.Duration `json:"reconnectInterval"`
	MaxReconnects     int           `json:"maxReconnects"`
	HeartbeatInterval time.Duration `json:"heartbeatInterval"`
	ConnectionTimeout time.Duration `json:"connectionTimeout"`
	PingInterval      time.Duration `json:"pingInterval"`
	PingTimeout       time.Duration `json:"pingTimeout"`
}

// DefaultStreamingConfig returns a default configuration
func DefaultStreamingConfig(rawURL, apiKey string) *StreamingConfig {
	return &StreamingConfig{
		URL:               rawURL,
		APIKey:            apiKey,
		ReconnectInterval: 5 * time.Second,
		MaxReconnects:     10,
		HeartbeatInterval: 30 * time.Second,
		ConnectionTimeout: 10 * time.Second,
		PingInterval:      20 * time.Second,
		PingTimeout:       5 * time.Second,
	}
}

// StreamingMessage represents a streaming message
type StreamingMessage struct {
	ID        string                 `json:"id,omitempty"`
	Channel   string                 `json:"channel"`
	Type      string                 `json:"type"`
	Data      interface{}            `json:"data,omitempty"`
	Timestamp int64                  `json:"timestamp,omitempty"`
	Headers   map[string]string      `json:"headers,omitempty"`
}

// MessageHandler defines the interface for message handlers
type MessageHandler interface {
	OnMessage(message *StreamingMessage)
	OnConnected()
	OnDisconnected()
	OnError(err error)
}

// BaseMessageHandler provides a default implementation of MessageHandler
type BaseMessageHandler struct{}

func (h *BaseMessageHandler) OnMessage(message *StreamingMessage) {}
func (h *BaseMessageHandler) OnConnected()                        {}
func (h *BaseMessageHandler) OnDisconnected()                    {}
func (h *BaseMessageHandler) OnError(err error)                  {}

// AsyncAPIStreamingClient represents the streaming client
type AsyncAPIStreamingClient struct {
	config           *StreamingConfig
	conn             *websocket.Conn
	mu               sync.RWMutex
	connected        bool
	reconnectAttempts int
	subscriptions    map[string]bool
	messageHandlers  map[string][]MessageHandler
	generalHandlers  []MessageHandler
	reconnectTimer   *time.Timer
	heartbeatTicker  *time.Ticker
	done             chan struct{}
}

// NewAsyncAPIStreamingClient creates a new streaming client
func NewAsyncAPIStreamingClient(config *StreamingConfig) *AsyncAPIStreamingClient {
	return &AsyncAPIStreamingClient{
		config:          config,
		subscriptions:   make(map[string]bool),
		messageHandlers: make(map[string][]MessageHandler),
		generalHandlers: make([]MessageHandler, 0),
		done:            make(chan struct{}),
	}
}

// Connect establishes connection to the streaming service
func (c *AsyncAPIStreamingClient) Connect(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	headers := make(http.Header)
	if c.config.APIKey != "" {
		headers.Set("Authorization", "Bearer "+c.config.APIKey)
	}

	dialer := &websocket.Dialer{
		HandshakeTimeout: c.config.ConnectionTimeout,
	}

	conn, _, err := dialer.DialContext(ctx, c.config.URL, headers)
	if err != nil {
		return fmt.Errorf("failed to connect: %w", err)
	}

	c.conn = conn
	c.connected = true
	c.reconnectAttempts = 0

	log.Printf("Connected to streaming service at %s", c.config.URL)

	// Notify handlers
	for _, handler := range c.generalHandlers {
		go handler.OnConnected()
	}

	// Start background tasks
	go c.messageLoop()
	go c.startHeartbeat()

	return nil
}

// Disconnect closes the connection
func (c *AsyncAPIStreamingClient) Disconnect() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.connected = false
	close(c.done)

	// Stop timers
	if c.reconnectTimer != nil {
		c.reconnectTimer.Stop()
	}
	if c.heartbeatTicker != nil {
		c.heartbeatTicker.Stop()
	}

	// Close connection
	if c.conn != nil {
		err := c.conn.Close()
		c.conn = nil
		return err
	}

	// Clear subscriptions
	c.subscriptions = make(map[string]bool)

	// Notify handlers
	for _, handler := range c.generalHandlers {
		go handler.OnDisconnected()
	}

	return nil
}

// Subscribe subscribes to a channel
func (c *AsyncAPIStreamingClient) Subscribe(channel string) error {
	c.mu.RLock()
	conn := c.conn
	connected := c.connected
	c.mu.RUnlock()

	if !connected || conn == nil {
		return fmt.Errorf("not connected")
	}

	c.mu.Lock()
	c.subscriptions[channel] = true
	c.mu.Unlock()

	subscriptionMessage := map[string]interface{}{
		"type":    "subscribe",
		"channel": channel,
		"id":      fmt.Sprintf("sub_%d", time.Now().UnixNano()),
	}

	return c.sendMessage(subscriptionMessage)
}

// Unsubscribe unsubscribes from a channel
func (c *AsyncAPIStreamingClient) Unsubscribe(channel string) error {
	c.mu.RLock()
	conn := c.conn
	connected := c.connected
	c.mu.RUnlock()

	if !connected || conn == nil {
		return fmt.Errorf("not connected")
	}

	c.mu.Lock()
	delete(c.subscriptions, channel)
	c.mu.Unlock()

	unsubscribeMessage := map[string]interface{}{
		"type":    "unsubscribe",
		"channel": channel,
		"id":      fmt.Sprintf("unsub_%d", time.Now().UnixNano()),
	}

	return c.sendMessage(unsubscribeMessage)
}

// Publish publishes a message to a channel
func (c *AsyncAPIStreamingClient) Publish(channel string, data interface{}) error {
	c.mu.RLock()
	conn := c.conn
	connected := c.connected
	c.mu.RUnlock()

	if !connected || conn == nil {
		return fmt.Errorf("not connected")
	}

	message := map[string]interface{}{
		"type":      "publish",
		"channel":   channel,
		"data":      data,
		"id":        fmt.Sprintf("pub_%d", time.Now().UnixNano()),
		"timestamp": time.Now().Unix(),
	}

	return c.sendMessage(message)
}

// SendRaw sends a raw message
func (c *AsyncAPIStreamingClient) SendRaw(data interface{}) error {
	c.mu.RLock()
	conn := c.conn
	connected := c.connected
	c.mu.RUnlock()

	if !connected || conn == nil {
		return fmt.Errorf("not connected")
	}

	return c.sendMessage(data)
}

// AddMessageHandler adds a message handler for a specific message type
func (c *AsyncAPIStreamingClient) AddMessageHandler(messageType string, handler MessageHandler) {
	if messageType == "*" {
		c.generalHandlers = append(c.generalHandlers, handler)
	} else {
		if c.messageHandlers[messageType] == nil {
			c.messageHandlers[messageType] = make([]MessageHandler, 0)
		}
		c.messageHandlers[messageType] = append(c.messageHandlers[messageType], handler)
	}
}

// RemoveMessageHandler removes a message handler
func (c *AsyncAPIStreamingClient) RemoveMessageHandler(messageType string, handler MessageHandler) {
	if messageType == "*" {
		for i, h := range c.generalHandlers {
			if h == handler {
				c.generalHandlers = append(c.generalHandlers[:i], c.generalHandlers[i+1:]...)
				break
			}
		}
	} else if handlers := c.messageHandlers[messageType]; handlers != nil {
		for i, h := range handlers {
			if h == handler {
				c.messageHandlers[messageType] = append(handlers[:i], handlers[i+1:]...)
				break
			}
		}
	}
}

// IsConnected returns true if connected
func (c *AsyncAPIStreamingClient) IsConnected() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.connected
}

// GetSubscriptions returns active subscriptions
func (c *AsyncAPIStreamingClient) GetSubscriptions() []string {
	c.mu.RLock()
	defer c.mu.RUnlock()

	subscriptions := make([]string, 0, len(c.subscriptions))
	for channel := range c.subscriptions {
		subscriptions = append(subscriptions, channel)
	}
	return subscriptions
}

// sendMessage sends a message through the websocket
func (c *AsyncAPIStreamingClient) sendMessage(data interface{}) error {
	message, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal message: %w", err)
	}

	c.mu.RLock()
	conn := c.conn
	c.mu.RUnlock()

	if conn == nil {
		return fmt.Errorf("connection not available")
	}

	return conn.WriteMessage(websocket.TextMessage, message)
}

// messageLoop handles incoming messages
func (c *AsyncAPIStreamingClient) messageLoop() {
	for {
		select {
		case <-c.done:
			return
		default:
			c.mu.RLock()
			conn := c.conn
			connected := c.connected
			c.mu.RUnlock()

			if !connected || conn == nil {
				return
			}

			messageType, message, err := conn.ReadMessage()
			if err != nil {
				log.Printf("Read error: %v", err)

				// Notify error handlers
				for _, handler := range c.generalHandlers {
					go handler.OnError(err)
				}

				c.handleReconnect()
				return
			}

			if messageType == websocket.TextMessage {
				c.processMessage(message)
			}
		}
	}
}

// processMessage processes an incoming message
func (c *AsyncAPIStreamingClient) processMessage(message []byte) {
	var msgData map[string]interface{}
	if err := json.Unmarshal(message, &msgData); err != nil {
		log.Printf("Failed to unmarshal message: %v", err)
		return
	}

	streamingMessage := &StreamingMessage{
		ID:      getStringValue(msgData, "id", ""),
		Channel: getStringValue(msgData, "channel", ""),
		Type:    getStringValue(msgData, "type", ""),
		Data:    msgData["data"],
	}

	if timestamp, ok := msgData["timestamp"].(float64); ok {
		streamingMessage.Timestamp = int64(timestamp)
	}

	// Notify general handlers
	for _, handler := range c.generalHandlers {
		go handler.OnMessage(streamingMessage)
	}

	// Notify type-specific handlers
	if handlers := c.messageHandlers[streamingMessage.Type]; handlers != nil {
		for _, handler := range handlers {
			go handler.OnMessage(streamingMessage)
		}
	}

	// Handle system messages
	if streamingMessage.Type == "heartbeat" {
		c.handleHeartbeat(streamingMessage)
	} else if streamingMessage.Type == "error" {
		log.Printf("Server error: %v", streamingMessage.Data)
	}
}

// handleHeartbeat handles heartbeat messages
func (c *AsyncAPIStreamingClient) handleHeartbeat(message *StreamingMessage) {
	response := map[string]interface{}{
		"type":      "heartbeat_response",
		"timestamp": time.Now().Unix(),
	}

	if err := c.sendMessage(response); err != nil {
		log.Printf("Failed to send heartbeat response: %v", err)
	}
}

// startHeartbeat starts the heartbeat timer
func (c *AsyncAPIStreamingClient) startHeartbeat() {
	c.heartbeatTicker = time.NewTicker(c.config.HeartbeatInterval)
	defer c.heartbeatTicker.Stop()

	for {
		select {
		case <-c.done:
			return
		case <-c.heartbeatTicker.C:
			c.mu.RLock()
			connected := c.connected
			c.mu.RUnlock()

			if connected {
				heartbeat := map[string]interface{}{
					"type":      "heartbeat",
					"timestamp": time.Now().Unix(),
				}

				if err := c.sendMessage(heartbeat); err != nil {
					log.Printf("Heartbeat failed: %v", err)
					return
				}
			}
		}
	}
}

// handleReconnect handles reconnection logic
func (c *AsyncAPIStreamingClient) handleReconnect() {
	c.mu.Lock()
	defer c.mu.Unlock()

	if !c.connected {
		return
	}

	c.connected = false
	if c.conn != nil {
		c.conn.Close()
		c.conn = nil
	}

	if c.reconnectAttempts >= c.config.MaxReconnects {
		log.Printf("Max reconnection attempts reached")
		return
	}

	c.reconnectAttempts++
	delay := time.Duration(float64(c.config.ReconnectInterval) * (1.5 * float64(c.reconnectAttempts-1)))

	log.Printf("Reconnecting in %v (attempt %d)", delay, c.reconnectAttempts)

	c.reconnectTimer = time.AfterFunc(delay, func() {
		ctx, cancel := context.WithTimeout(context.Background(), c.config.ConnectionTimeout)
		defer cancel()

		if err := c.Connect(ctx); err != nil {
			log.Printf("Reconnection failed: %v", err)
			c.handleReconnect()
		}
	})
}

// Utility functions

func getStringValue(data map[string]interface{}, key, defaultValue string) string {
	if value, ok := data[key].(string); ok {
		return value
	}
	return defaultValue
}

// Protocol-specific client factories

// NewWebSocketClient creates a WebSocket streaming client
func NewWebSocketClient(rawURL, apiKey string) *AsyncAPIStreamingClient {
	config := DefaultStreamingConfig(rawURL, apiKey)
	return NewAsyncAPIStreamingClient(config)
}

// NewMQTTClient creates an MQTT streaming client
// Note: MQTT implementation would require additional dependencies
func NewMQTTClient(brokerURL, clientID, apiKey string) *AsyncAPIStreamingClient {
	config := DefaultStreamingConfig(brokerURL, apiKey)
	return NewAsyncAPIStreamingClient(config)
}

// NewKafkaClient creates a Kafka streaming client
// Note: Kafka implementation would require additional dependencies
func NewKafkaClient(brokerURL, groupID, apiKey string) *AsyncAPIStreamingClient {
	config := DefaultStreamingConfig(brokerURL, apiKey)
	return NewAsyncAPIStreamingClient(config)
}
